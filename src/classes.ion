
export const
    getSourceErrorDetails = (message, source, index, sourceName = 'anonymous') ->
        let errorLines = source.substring(0, index).split(/\r?\n/)
        let columnNumber = errorLines[errorLines.length - 1].length + 1
        let lineNumber = errorLines.length
        let lines = source.split(/\r?\n/)
        let lineSource = lines[lineNumber - 1]
        let pointer = "^"
        for let i = 1; i < columnNumber; i++
            pointer = " " + pointer

        return
            lineNumber: lineNumber
            columnNumber: columnNumber
            lineSource: lineSource
            message: "({{sourceName}}):{{lineNumber}}:{{columnNumber}}: {{message}}\n{{lineSource}}\n{{pointer}}"

    Context = class Context
        constructor: (grammar, source, index, state, root) ->
            @grammar = grammar
            @source = source
            @index = index ? 0
            @string = @source.substring(@index)
            @state = state ? {}
            @text = null # the text of the rule just matched
            Object.defineProperty(@, "root", {value:root ? @})
            if not root?
                @failIndex = -1
                @failExpecteds = {}
        properties:
            consume: (count) ->
                @index += count
                @string = @source.substring(@index)
            clone: -> new Context(@grammar, @source, @index, JSON.parse(JSON.stringify(@state)), @root)
            setFrom: (context) ->
                @string = context.string
                @index = context.index
                @state = context.state
            fail: (expected) ->
                if @index >= @root.failIndex
                    if @index > @root.failIndex
                        @root.failExpecteds = {}
                        @root.failIndex = @index
                    @root.failExpecteds[expected] = true
            getErrorDetails: (sourceName) ->
                if @index is @source.length
                    return null
                let fails = Object.keys(@failExpecteds)
                if fails.length > 0
                    return getSourceErrorDetails("Expected: {{fails.join(' | ')}}", @source, @failIndex, sourceName)
                return getSourceErrorDetails("Unexpected:", @source, @index, sourceName)

    Rule = class Rule
        properties:
            parse: (context) ->
                # if fail => return undefined and DO NOT modify context
                # if succeed => return result and MAY modify context
            set: (properties) ->
                for key, value of properties
                    @[key] = value
                return @

    Grammar = class Grammar extends Rule
        constructor: (rules) ->
            @rules = rules
            for name, rule of rules
                @start = rule
                break
        properties:
            parse: (source, sourceName) ->
                let context = new Context(@, source)
                let result = @start.parse(context)
                let errorDetails = context.getErrorDetails(sourceName)
                if errorDetails
                    throw new SyntaxError(errorDetails.message)
                return result

    Reference = class Reference extends Rule
        constructor: (name) ->
            @name = name
        properties:
            parse: (context) ->
                let rule = context.grammar.rules[@name]
                if not rule?
                    throw new Error("Rule not found: {{@name}}")
                return rule.parse(context)
            toString: -> @name

    Terminal = class Terminal extends Rule
        constructor: (text) ->
            @stringValue = text.source? ? "/{{text.source}}/" : JSON.stringify(text)
            if text.source?
                text = new RegExp('^' + text.source)
            @text = text
        properties:
            parse: (context) ->
                let text = @text
                let result = undefined
                if typeof text is 'string'
                    # string literal
                    if context.string.startsWith(text)
                        result = text
                else
                    # regular expression
                    let match = context.string.match(text)
                    result = match?[0]
                if result?
                    context.consume(result.length)
                else
                    context.fail(@name ? @stringValue)
                return result
            toString: -> @stringValue

    Any = class Any extends Rule
        properties:
            parse: (context) ->
                let result = context.string.substring(0, 1)
                if result.length is 0
                    return undefined
                else
                    context.consume(result.length)
                    return result

    Sequence = class Sequence extends Rule
        constructor: (...rules) ->
            @rules = rules
        properties:
            labels:
                # name -> index
                type: 'object'
                value: null
                writable: true
            extract:
                # index of a single value to extract
                type: ['integer','array']
                value: null
                writable: true
            parse: (context) ->
                let clone = context.clone()
                let results = undefined
                for rule in @rules
                    let result = rule.parse(clone, results ? [])
                    if result is undefined
                        return undefined
                    else
                        results ?= []
                        results.push(result)
                context.setFrom(clone)
                if results?
                    if @extract? and @labels?
                        throw new Error("Rule cannot contain both @ and labels: " + this)
                    if @extract?
                        if Array.isArray(@extract)
                            return [results[index] for index in @extract]
                        else
                            return results[@extract]
                    if @labels?
                        for name, index of @labels
                            results[name] = results[index]
                return results
            toString: -> "({{@rules.join(' ')}})"

    Choice = class Choice extends Rule
        constructor: (...rules) ->
            @rules = rules
        properties:
            parse: (context) ->
                for rule in @rules
                    let result = rule.parse(context)
                    if result isnt undefined
                        return result
                return undefined
            toString: -> "({{@rules.join(' / ')}})"

    Repeat = class Repeat extends Rule
        constructor: (rule, minimum, maximum) ->
            @rule = rule
            @minimum = minimum ? 0
            @maximum = maximum ? Number.MAX_VALUE
        properties:
            parse: (context) ->
                let minimum = @minimum
                if typeof minimum is 'string'
                    minimum = context.state[minimum] ? 0
                let maximum = @maximum
                if typeof maximum is 'string'
                    maximum = context.state[maximum] ? 0

                let clone = context.clone()
                let results = null
                for let i = 0; i < maximum; i++
                    let index = clone.index
                    let result = @rule.parse(clone)
                    if result is undefined
                        break
                    results ?= []
                    results.push(result)
                    if clone.index is index
                        console.warn("Repeating rule did not consume input:" + @rule.toString())
                        break
                        # throw new Error("Repeating rule did not consume input:" + @rule.toString())
                if (results?.length ? 0) >= minimum
                    context.setFrom(clone)
                    return results ? []
                else
                    return undefined
            toString: ->
                if @maximum is Number.MAX_VALUE
                    if @minimum is 0
                        return rule + "*"
                    if @minimum is 1
                        return rule + "+"
                    return rule + "[{{@minimum}}+]"
                else
                    return rule + "[{{@minimum}}-{{@maximum}}]"

    Add = class Add extends Rule
        constructor: (name, value) ->
            @name = name
            @value = value ? 1
        properties:
            parse: (context) ->
                context.state[@name] ?= 0
                context.state[@name] += @value
                return null
            toString: -> "[{{@name}}+={{@value}}]"

    Option = class Option extends Rule
        constructor: (rule) ->
            @rule = rule
        properties:
            parse: (context) ->
                let result = @rule.parse(context)
                if result is undefined
                    return null
                else
                    return result
            toString: -> "{{@rule}}?"

    And = class And extends Rule
        constructor: (rule) ->
            @rule = rule
        properties:
            parse: (context) ->
                let clone = context.clone()
                let result = @rule.parse(clone)
                if result is undefined
                    return undefined
                else
                    return null
            toString: -> "&{{@rule}}"

    Not = class Not extends Rule
        constructor: (rule) ->
            @rule = rule
        properties:
            parse: (context) ->
                let clone = context.clone()
                let result = @rule.parse(clone)
                if result is undefined
                    return null
                else
                    return undefined
            toString: -> "!{{@rule}}"

    CustomPredicate = class CustomPredicate extends Rule
        constructor: (predicate) ->
            @predicate = predicate
        properties:
            parse: (context, results) ->
                # must clone since custom code may alter the state and we might need to roll back
                let clone = context.clone()
                if @predicate.call(clone, results) isnt false
                    context.setFrom(clone)
                    return null
                else
                    return undefined
            toString: -> "&{{@predicate.toString()}}"

    Filter = class Filter extends Rule
        constructor: (rule, filter) ->
            @rule = rule
            @filter = filter
        properties:
            parse: (context) ->
                let startIndex = context.index
                let result = @rule.parse(context)
                if result isnt undefined
                    let endIndex = context.index
                    context.text = context.source.substring(startIndex, endIndex)
                    let customResult = @filter.call(context, result)
                    if customResult isnt undefined
                        result = customResult
                return result
            toString: -> "{{@rule}} {{@filter.toString()}}"

    StringResult = class StringResult extends Rule
        constructor: (rule) ->
            @rule = rule
        properties:
            parse: (context) ->
                let start = context.index
                let result = @rule.parse(context)
                if result isnt undefined
                    let end = context.index
                    result = context.source.substring(start, end)
                return result
            toString: -> "${{@rule}}"

    # CustomRule = class CustomRule extends Rule
    #     constructor: (parseFunction) ->
    #         @parseFunction = parseFunction
    #     properties:
    #         parse: (context) -> @parseFunction.call(context, context)
    #         toString: -> "{{@parseFunction.toString()}}"


