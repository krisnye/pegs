const {Grammar,Filter,Sequence,Reference,Terminal,Option,Repeat,Add,Choice,Not,Any,And,StringResult} = import './classes'

const
    escodegen = import './escodegen'
    whitespace = new Terminal(/ *([\r\n]+ +)*/, 'whitespace')
    NewExpression = (type, args) -> {type:'NewExpression', callee:{type:'Identifier', name:type}, arguments:args ? []}

const grammar = new Grammar(
    start: new Reference('grammar')
    grammar: new Filter(
        new Sequence(
            new Option(new Reference('code'))
            new Reference('rules')
            new Terminal(/[\s\r\n]*/)
        )
            labels:
                code: 0
                rules: 1
        ({code,rules}) ->
            let rulesArg =
                type: 'ObjectExpression'
                properties: []
                    for [id,expression] in rules
                        {}
                            type: 'Property'
                            key:
                                type: 'Identifier'
                                name: id
                            value: expression
                            kind: 'init'
            let grammar = NewExpression('Grammar', [rulesArg])
            let result =
                type: 'Program'
                body: []
                    if code?
                        {type:'ExpressionStatement', expression:{type:'Literal', "x-verbatim":code}}
                    # insert pegs import bullshit here.
                    {}
                        type: 'VariableDeclaration'
                        kind: 'var'
                        declarations: []
                            {}
                                type: 'VariableDeclarator'
                                id: { type: 'Identifier', name: '_classes_' }
                                init:
                                    type: 'MemberExpression'
                                    object:
                                        type: 'CallExpression'
                                        callee: { type: 'Identifier', name: 'require' }
                                        # bootstrap can only be used for compiling ourselves
                                        # since this reference to the pegs library uses './'
                                        arguments: [ {type: 'Literal', value: './' } ]
                                    property: { type: 'Literal', name: 'classes' }
                            for id of import './classes'
                                {}
                                    type: 'VariableDeclarator'
                                    id: { type: 'Identifier', name: id }
                                    init:
                                        type: 'MemberExpression'
                                        object: { type: 'Identifier', name: '_classes_' }
                                        property: { type: 'Identifier', name: id }
                    {}
                        type: 'ExpressionStatement'
                        expression:
                            type: 'AssignmentExpression'
                            operator: '='
                            left:
                                type: 'MemberExpression'
                                object:
                                    type: 'Identifier'
                                    name: 'module'
                                property:
                                    type: 'Identifier'
                                    name: 'exports'
                            right: grammar
            # return grammar
            # console.log(JSON.stringify(grammar, null, '  '))
            return escodegen.generate(result, {verbatim:'x-verbatim'})
    )
    rules: new Repeat(
        new Reference('rule')
        1
    )
    rule: new Filter(
        new Sequence(
            new Terminal(/\s*/)
            new Reference('id')
            new Terminal(/\s*/)
            new Option(
                new Sequence(
                    new Reference('string')
                    new Terminal(/\s*/)
                )
                    extract: 0
            )
            new Terminal('=')
            new Terminal(/\s*/)
            new Reference('expression')
        )
            labels:
                id: 1
                name: 3
                expression: 6
        ({id,expression,name}) ->
            if name?
                expression =
                    type: 'CallExpression'
                    callee:
                        type: 'MemberExpression'
                        object: expression
                        property:
                            type: 'Identifier'
                            name: 'set'
                    arguments: []
                        {}
                            type: 'ObjectExpression'
                            properties: []
                                {}
                                    type: 'Property'
                                    key:
                                        type: 'Literal'
                                        value: 'name'
                                    value: name
            return [id,expression]
    )
    expression: new Reference('choice')
    choice: new Filter(
        new Sequence(
            new Reference('filter')
            new Repeat(
                new Sequence(
                    whitespace
                    new Terminal('|')
                    whitespace
                    new Reference('filter')
                )
                    extract: 3
            )
        )
        ([first,rest]) ->
            if rest.length > 0
                return NewExpression('Choice', [first].concat(rest))
            else
                return first
    )
    filter: new Filter(
        new Sequence(
            new Reference('sequence')
            whitespace
            new Option(new Reference('code'))
        )
            labels:
                e: 0
                code: 2
        ({e,code}) ->
            if code?
                let init = ""
                if e.sequenceLabels?
                    # console.log('sequenceLabels', e.sequenceLabels)
                    init = []
                        for label in e.sequenceLabels
                            "var {{label.key.value}} = value.{{label.key.value}}; "
                    .join('')

                return NewExpression('Filter', [e,{"x-verbatim":"function(value){ {{init}}{{code}} }"}])
            else
                return e
    )
    sequence: new Filter(
        new Sequence(
            new Reference('labeledRepeat')
            new Repeat(
                new Sequence(
                    whitespace
                    new Reference('labeledRepeat')
                )
                    extract: 1
            )
        )
        ([first,rest]) ->
            if rest.length > 0 or Array.isArray(first)
                let items = [first].concat(rest)
                let labels = null
                let extract = null
                for item, index in items
                    if Array.isArray(item)
                        if item[0] is true
                            if extract?
                                if not Array.isArray(extract)
                                    extract = [extract]
                                extract.push(index)
                            else
                                extract = index
                        else
                            labels ?= []
                            labels.push({type:'Property',key:item[0],value:{type:'Literal',value:index,kind:'init'}})
                        items[index] = item[1]

                let result = NewExpression('Sequence', items)
                if labels?.length > 0 or extract?
                    result =
                        sequenceLabels: labels
                        type: 'CallExpression'
                        callee:
                            type: 'MemberExpression'
                            object: result
                            property:
                                type: 'Identifier'
                                name: 'set'
                        arguments: []
                            {}
                                type: 'ObjectExpression'
                                properties: []
                                    if extract?
                                        {}
                                            type: 'Property'
                                            key:
                                                type: 'Literal'
                                                value: 'extract'
                                            if Array.isArray(extract)
                                                value:
                                                    type: 'ArrayExpression'
                                                    elements: []
                                                        for index in extract
                                                            {type:'Literal',value:index}
                                            else
                                                value:
                                                    type: 'Literal'
                                                    value: extract
                                    if labels?.length > 0
                                        {}
                                            type: 'Property'
                                            key:
                                                type: 'Literal'
                                                value: 'labels'
                                            value:
                                                type: 'ObjectExpression'
                                                properties: labels
                return result
            else
                return first
    )
    labeledRepeat: new Choice(
        new Filter(
            new Sequence(
                new Terminal('@')
                whitespace
                new Reference('repeat')
            )
                extract: 2
            (rule) -> [true, rule]
        )
        new Filter(
            new Sequence(
                new Reference('idLiteral')
                whitespace
                new Terminal(':')
                whitespace
                new Reference('repeat')
            )
                labels:
                    id: 0
                    rule: 4
            ({id,rule}) -> [id, rule]
        )
        new Reference('repeat')
    )
    repeat: new Filter(
        new Sequence(
            new Reference('atomicRule')
            whitespace
            new Option(new Reference('quantifier'))
        )
            labels:
                rule: 0
                quantifier: 2
        ({rule,quantifier}) ->
            if not quantifier?
                return rule
            let args = [rule]
            if quantifier is '?'
                return NewExpression('Option', args)
            if quantifier is '*'
                args.push({type:'Literal',value:0})
            else if quantifier is '+'
                args.push({type:'Literal',value:1})
            else
                args = args.concat(quantifier)
            return NewExpression('Repeat', args)
    )
    quantifier: new Choice(
        new Terminal('?')
        new Terminal('*')
        new Terminal('+')
        new Filter(
            new Sequence(
                new Terminal('[')
                whitespace
                new Reference('integerOrString')
                whitespace
                new Option(
                    new Choice(
                        new Terminal('+')
                        new Sequence(
                            new Terminal('-')
                            whitespace
                            new Reference('integerOrString')
                        )
                            extract: 2
                    )
                )
                whitespace
                new Terminal(']')
            )
                labels:
                    min: 2
                    max: 4
            ({min,max}) ->
                if max is '+'
                    return [min]
                else
                    return [min, max ? min]
        )
    )
    atomicRule: new Choice(
        new Reference('terminal')
        new Reference('group')
        new Reference('any')
        new Reference('reference')
        new Reference('customPredicate')
        new Reference('andPredicate')
        new Reference('notPredicate')
        new Reference('stringResult')
    )
    reference: new Filter(
        new Reference('idLiteral')
        (value) -> NewExpression('Reference', [value])
    )
    group: new Sequence(
        new Terminal("(")
        whitespace
        new Reference('expression')
        whitespace
        new Terminal(")")
    )
        extract: 2
    customPredicate: new Filter(
        new Sequence(
            new Terminal("&")
            whitespace
            new Reference('code')
        )
            extract: 2
        (value) -> NewExpression('CustomPredicate', [{"x-verbatim":"function(){ {{value}} }"}])
    )
    andPredicate: new Filter(
        new Sequence(
            new Terminal("&")
            whitespace
            new Reference('atomicRule')
        )
            extract: 2
        (value) -> NewExpression('And', [value])
    )
    notPredicate: new Filter(
        new Sequence(
            new Terminal("!")
            whitespace
            new Reference('atomicRule')
        )
            extract: 2
        (value) -> NewExpression('Not', [value])
    )
    stringResult: new Filter(
        new Sequence(
            new Terminal("$")
            whitespace
            new Reference('atomicRule')
        )
            extract: 2
        (value) -> NewExpression('StringResult', [value])
    )
    terminal: new Filter(
        new Choice(new Reference('string'), new Reference('regex'))
        (value) -> NewExpression('Terminal', [value])
    )
    idLiteral: new Filter(new Reference('id'), (value) -> {type:'Literal', value})
    id: new Terminal(/[_a-zA-Z][_a-zA-Z0-9]*/)
    integerOrString: new Choice(new Reference('integer'), new Reference('string'))
    integer: new Filter(new Terminal(/[0-9]+/), (value) -> {type:'Literal',value:parseInt(value)})
    string: new Filter(
        new Choice(
            new Terminal(/("([^"\\]*|\\["\/\\bfnrt]|\\u[0-9a-f]{4})*")/, 'string')
            new Terminal(/('([^'\\]*|\\['\/\\bfnrt]|\\u[0-9a-f]{4})*')/, 'string')
        )
        (value) -> {type:'Literal',value:eval(value)}
    )
    regex: new Filter(new Terminal(/\/(\\.|[^\/])+\//, 'regex'), (value) -> {type:'Literal',value:eval(value)})
    any: new Filter(new Terminal('.'), (value) -> NewExpression('Any'))
    code: new Choice(new Reference('ioncode'), new Reference('jscode'))
    ioncode: new Filter(
        new Sequence(
            new Terminal('{')
            new Reference('jscode')
            new Terminal('}')
        )
            extract: 1
        (value) -> require('ion').compiler.compile(value)
    )
    jscode: new Filter(
        new StringResult(
            new Sequence(
                whitespace
                new Terminal('{')
                new Repeat(
                    new Choice(
                        new Terminal(/[^{}]+/)
                        new Reference('code')
                    )
                )
                new Terminal('}')
            )
        )
        (value) -> value.trim().slice(1, -1)
    )
    crlf: new Choice(
        new Terminal(/\r?\n/, 'crlf')
        new Reference('eof')
    )
    eof: new Not(new Any())
)
export grammar
    test: ->
        # let fs = require('fs')
        # console.log(fs.readFileSync('lib/parser.js', 'utf8'))

        # let test = ""
        #     start = x:"x" y:"y" { return x + "-" + y }
        #     foo = a @b
        #     bar = a @b c @d e @f
        #     baz = $(a b)
        # let result = grammar.parse(test)
        # let escodegen = import './escodegen'
        # console.log('-----------------------------------------------------')
        # console.log(result)
        # console.log('-----------------------------------------------------')
        # # console.log(escodegen.generate(result, {verbatim:'x-verbatim'}))
        # # console.log('-----------------------------------------------------')
