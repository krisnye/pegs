start = grammar

ws = (' ' / '	' / '\n')*

colon = ws ':' ws
lcurl = ws '{' ws
rcurl = ws '}' ws
lbrac = ws '[' ws
rbrac = ws ']' ws
lpar = ws '(' ws
rpar = ws ')' ws
star = ws '*' ws
plus = ws '+' ws
or = ws '/' ws
eq = ws '=' ws
dot = ws '.' ws
exclamation = ws '!' ws
question = ws '?' ws
dollar = ws '$' ws

primitive = reference / string / charrange / parenthesis / any
identifier = ws k: $([a-z] / [A-Z])+ ws {return k}
reference = k: identifier !eq {return "new Reference(" + JSON.stringify(k) + ")"}
string = ws k: (doublequote / singlequote) ws {return "new Terminal(" + JSON.stringify(k) + ")"}
doublequote = '"' k: $(!'"' .)* '"' {return k}
singlequote = "'" k: $(!"'" .)* "'" {return k}
charrange = lbrac lower: . '-' upper: . rbrac {return "new CharRange(" + JSON.stringify(lower) + "," + JSON.stringify(upper) + ")"}
parenthesis = lpar k: expression rpar {return k}
any = dot {return "new Any()"}

unary = not / optional / stringValue
not = exclamation k: primitive {return "new NotPredicate(" + k + ")"}
optional = k: primitive question {return "new Optional("  + k + ")"}
stringValue = dollar k: primitive {return "new StringValue("  + k + ")"}
unaryOrLess = unary / primitive

repeat = k: unaryOrLess star {return "new Repeat(" + k + ")"}
repeatOne = k: unaryOrLess plus {return "new Repeat(" + k + ", 1)"}
repeatOrLess = repeat / repeatOne / unaryOrLess

choice = head: repeatOrLess tail: (or k: repeatOrLess {return k})+ 
{return "new Choice(" + [head].concat(tail).join(", ") + ")"}
choiceOrLess = choice / repeatOrLess

label = name: identifier colon ws value: choiceOrLess {return value + ".setName(" + JSON.stringify(name) + ")"}
labelOrLess = label / choiceOrLess

sequence = head: labelOrLess tail: (ws k: labelOrLess {return k})+
{return "new Sequence(" + [head].concat(tail).join(", ") + ")"}
sequenceOrLess = sequence / labelOrLess

action = k: sequence js: jsblock {return "new Action(" + k + ", " + JSON.stringify(js) + ")"}
actionSingle = k: sequenceOrLess js: jsblock {return "new Action(new Sequence(" + k + "), " + JSON.stringify(js) + ")"}
actionOrLess = actionSingle / action / sequenceOrLess

expression = actionOrLess

assignment = lval: identifier eq rval: expression {return rval + ".setName(" + JSON.stringify(lval) + ")"}
grammar = k: (k: assignment {return k})* {return "return new Grammar([\n    " + k.join(",\n    ") + "\n])"}

jsany = comment / string / regex / jsblock / .
regex = slash (!slash .)* slash
slash = '/'
comment = '//' (!'\n' .)* '\n'?
nonbrac = !rcurl jsany
jsblock = lcurl js: $nonbrac* rcurl {return js}